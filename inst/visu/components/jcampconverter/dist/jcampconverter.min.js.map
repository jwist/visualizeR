{"version":3,"sources":["webpack:///jcampconverter/webpack/universalModuleDefinition","webpack:///jcampconverter/webpack/bootstrap ef84fed5bae05ddbd4fc","webpack:///jcampconverter/./src/index.js"],"names":[],"mappings":"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","file":"jcampconverter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ef84fed5bae05ddbd4fc","'use strict';\n\nfunction getConverter() {\n    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n    const ntuplesSeparator = /[, \\t]+/;\n    const GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n    function convertToFloatArray(stringArray) {\n        var l = stringArray.length;\n        var floatArray = new Array(l);\n        for (var i = 0; i < l; i++) {\n            floatArray[i] = parseFloat(stringArray[i]);\n        }\n        return floatArray;\n    }\n\n    class Spectrum {}\n\n    const defaultOptions = {\n        keepRecordsRegExp: /^$/,\n        xy: false,\n        withoutXY: false,\n        chromatogram: false,\n        keepSpectra: false,\n        noContour: false,\n        nbContourLevels: 7,\n        noiseMultiplier: 5\n    };\n\n    function convert(jcamp, options) {\n        options = Object.assign({}, defaultOptions, options);\n\n        var wantXY = !options.withoutXY;\n\n        var start = Date.now();\n\n        var ntuples = {};\n        var ldr, dataLabel, dataValue, ldrs;\n        var i, ii, j, position, endLine, infos;\n\n        var result = {};\n        result.profiling = [];\n        result.logs = [];\n        var spectra = [];\n        result.spectra = spectra;\n        result.info = {};\n        var spectrum = new Spectrum();\n\n        if (!(typeof jcamp === 'string')) {\n            throw new TypeError('the JCAMP should be a string');\n        }\n\n        if (result.profiling) {\n            result.profiling.push({\n                action: 'Before split to LDRS',\n                time: Date.now() - start\n            });\n        }\n\n        ldrs = jcamp.split(/[\\r\\n]+##/);\n\n        if (result.profiling) {\n            result.profiling.push({\n                action: 'Split to LDRS',\n                time: Date.now() - start\n            });\n        }\n\n        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n        for (i = 0, ii = ldrs.length; i < ii; i++) {\n            ldr = ldrs[i];\n            // This is a new LDR\n            position = ldr.indexOf('=');\n            if (position > 0) {\n                dataLabel = ldr.substring(0, position);\n                dataValue = ldr.substring(position + 1).trim();\n            } else {\n                dataLabel = ldr;\n                dataValue = '';\n            }\n            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n            if (dataLabel === 'DATATABLE') {\n                endLine = dataValue.indexOf('\\n');\n                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n                if (endLine > 0) {\n                    var xIndex = -1;\n                    var yIndex = -1;\n                    // ##DATA TABLE= (X++(I..I)), XYDATA\n                    // We need to find the variables\n\n                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n                    if (infos[0].indexOf('++') > 0) {\n                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n                        xIndex = ntuples.symbol.indexOf(firstVariable);\n                        yIndex = ntuples.symbol.indexOf(secondVariable);\n                    }\n\n                    if (xIndex === -1) xIndex = 0;\n                    if (yIndex === -1) yIndex = 0;\n\n                    if (ntuples.first) {\n                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n                    }\n                    if (ntuples.last) {\n                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n                    }\n                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n                        spectrum.nbPoints = ntuples.vardim[xIndex];\n                    }\n                    if (ntuples.factor) {\n                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n                    }\n                    if (ntuples.units) {\n                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n                    }\n                    spectrum.datatable = infos[0];\n                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n                        dataLabel = 'PEAKTABLE';\n                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n                        dataLabel = 'XYDATA';\n                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                    }\n                }\n            }\n\n            if (dataLabel === 'XYDATA') {\n                if (wantXY) {\n                    prepareSpectrum(result, spectrum);\n                    // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n                    if (dataValue.match(/.*\\+\\+.*/)) {\n                        if (!spectrum.deltaX) {\n                            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                        }\n                        fastParseXYData(spectrum, dataValue, result);\n                    } else {\n                        parsePeakTable(spectrum, dataValue, result);\n                    }\n                    spectra.push(spectrum);\n                    spectrum = new Spectrum();\n                }\n                continue;\n            } else if (dataLabel === 'PEAKTABLE') {\n                if (wantXY) {\n                    prepareSpectrum(result, spectrum);\n                    parsePeakTable(spectrum, dataValue, result);\n                    spectra.push(spectrum);\n                    spectrum = new Spectrum();\n                }\n                continue;\n            }\n\n\n            if (dataLabel === 'TITLE') {\n                spectrum.title = dataValue;\n            } else if (dataLabel === 'DATATYPE') {\n                spectrum.dataType = dataValue;\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'NTUPLES') {\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'XUNITS') {\n                spectrum.xUnit = dataValue;\n            } else if (dataLabel === 'YUNITS') {\n                spectrum.yUnit = dataValue;\n            } else if (dataLabel === 'FIRSTX') {\n                spectrum.firstX = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTX') {\n                spectrum.lastX = parseFloat(dataValue);\n            } else if (dataLabel === 'FIRSTY') {\n                spectrum.firstY = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTY') {\n                spectrum.lastY = parseFloat(dataValue);\n            } else if (dataLabel === 'NPOINTS') {\n                spectrum.nbPoints = parseFloat(dataValue);\n            } else if (dataLabel === 'XFACTOR') {\n                spectrum.xFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'YFACTOR') {\n                spectrum.yFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'DELTAX') {\n                spectrum.deltaX = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVENUCLEUS') {\n                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n            } else if (dataLabel === '$SFO2') {\n                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\n            } else if (dataLabel === '$OFFSET') { // OFFSET for Bruker spectra\n                result.shiftOffsetNum = 0;\n                if (!result.shiftOffsetVal) result.shiftOffsetVal = parseFloat(dataValue);\n            } else if (dataLabel === '$REFERENCEPOINT') { // OFFSET for Varian spectra\n\n\n                // if we activate this part it does not work for ACD specmanager\n                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n                //                 var parts = dataValue.split(/ *, */);\n                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n            } else if (dataLabel === 'VARNAME') {\n                ntuples.varname = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'SYMBOL') {\n                ntuples.symbol = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARTYPE') {\n                ntuples.vartype = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARFORM') {\n                ntuples.varform = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARDIM') {\n                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'UNITS') {\n                ntuples.units = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'FACTOR') {\n                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'FIRST') {\n                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'LAST') {\n                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MIN') {\n                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MAX') {\n                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === '.NUCLEUS') {\n                if (result.twoD) {\n                    result.yType = dataValue.split(ntuplesSeparator)[0];\n                }\n            } else if (dataLabel === 'PAGE') {\n                spectrum.page = dataValue.trim();\n                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n                spectrum.pageSymbol = spectrum.page.replace(/[=].*/, '');\n                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n                var unit = '';\n                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n                    unit = ntuples.units[pageSymbolIndex];\n                }\n                if (result.indirectFrequency && unit !== 'PPM') {\n                    spectrum.pageValue /= result.indirectFrequency;\n                }\n            } else if (dataLabel === 'RETENTIONTIME') {\n                spectrum.pageValue = parseFloat(dataValue);\n            } else if (isMSField(dataLabel)) {\n                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n            }\n            if (dataLabel.match(options.keepRecordsRegExp)) {\n                result.info[dataLabel] = dataValue.trim();\n            }\n        }\n\n        if (result.profiling) {\n            result.profiling.push({\n                action: 'Finished parsing',\n                time: Date.now() - start\n            });\n        }\n\n        if (Object.keys(ntuples).length > 0) {\n            var newNtuples = [];\n            var keys = Object.keys(ntuples);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var values = ntuples[key];\n                for (j = 0; j < values.length; j++) {\n                    if (!newNtuples[j]) newNtuples[j] = {};\n                    newNtuples[j][key] = values[j];\n                }\n            }\n            result.ntuples = newNtuples;\n        }\n\n        if (result.twoD && wantXY) {\n            add2D(result, options);\n            if (result.profiling) {\n                result.profiling.push({\n                    action: 'Finished countour plot calculation',\n                    time: Date.now() - start\n                });\n            }\n            if (!options.keepSpectra) {\n                delete result.spectra;\n            }\n        }\n\n        if (options.chromatogram) {\n            options.xy = true;\n        }\n\n        if (options.xy && wantXY) { // the spectraData should not be a oneD array but an object with x and y\n            if (spectra.length > 0) {\n                for (i = 0; i < spectra.length; i++) {\n                    spectrum = spectra[i];\n                    if (spectrum.data.length > 0) {\n                        for (j = 0; j < spectrum.data.length; j++) {\n                            var data = spectrum.data[j];\n                            var newData = {\n                                x: new Array(data.length / 2),\n                                y: new Array(data.length / 2)\n                            };\n                            for (var k = 0; k < data.length; k = k + 2) {\n                                newData.x[k / 2] = data[k];\n                                newData.y[k / 2] = data[k + 1];\n                            }\n                            spectrum.data[j] = newData;\n                        }\n\n                    }\n\n                }\n            }\n        }\n\n        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n        if (options.chromatogram) {\n            if (result.spectra.length > 1) {\n                complexChromatogram(result);\n            } else {\n                simpleChromatogram(result);\n            }\n            if (result.profiling) {\n                result.profiling.push({\n                    action: 'Finished chromatogram calculation',\n                    time: Date.now() - start\n                });\n            }\n        }\n\n        if (result.profiling) {\n            result.profiling.push({\n                action: 'Total time',\n                time: Date.now() - start\n            });\n        }\n\n        return result;\n    }\n\n\n    function convertMSFieldToLabel(value) {\n        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n    }\n\n    function isMSField(dataLabel) {\n        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n    }\n\n    function complexChromatogram(result) {\n        var spectra = result.spectra;\n        var length = spectra.length;\n        var chromatogram = {\n            times: new Array(length),\n            series: {\n                ms: {\n                    dimension: 2,\n                    data: new Array(length)\n                }\n            }\n        };\n\n        var i;\n        var existingGCMSFields = [];\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n                chromatogram.series[label] = {\n                    dimension: 1,\n                    data: new Array(length)\n                };\n            }\n        }\n\n        for (i = 0; i < length; i++) {\n            var spectrum = spectra[i];\n            chromatogram.times[i] = spectrum.pageValue;\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                chromatogram.series[existingGCMSFields[j]].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n            }\n            if (spectrum.data) {\n                chromatogram.series.ms.data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n            }\n\n        }\n        result.chromatogram = chromatogram;\n    }\n\n    function simpleChromatogram(result) {\n        var data = result.spectra[0].data[0];\n        result.chromatogram = {\n            times: data.x.slice(),\n            series: {\n                intensity: {\n                    dimension: 1,\n                    data: data.y.slice()\n                }\n            }\n        };\n    }\n\n    function prepareSpectrum(result, spectrum) {\n        if (!spectrum.xFactor) spectrum.xFactor = 1;\n        if (!spectrum.yFactor) spectrum.yFactor = 1;\n        if (spectrum.observeFrequency) {\n            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n                spectrum.xUnit = 'PPM';\n                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n            }\n        }\n        if (result.shiftOffsetVal) {\n            var shift = spectrum.firstX - result.shiftOffsetVal;\n            spectrum.firstX = spectrum.firstX - shift;\n            spectrum.lastX = spectrum.lastX - shift;\n        }\n    }\n\n    function getMedian(data) {\n        data = data.sort(compareNumbers);\n        var l = data.length;\n        return data[Math.floor(l / 2)];\n    }\n\n    function compareNumbers(a, b) {\n        return a - b;\n    }\n\n    function convertTo3DZ(spectra) {\n        var minZ = spectra[0].data[0][0];\n        var maxZ = minZ;\n        var ySize = spectra.length;\n        var xSize = spectra[0].data[0].length / 2;\n        var z = new Array(ySize);\n        for (var i = 0; i < ySize; i++) {\n            z[i] = new Array(xSize);\n            var xVector = spectra[i].data[0];\n            for (var j = 0; j < xSize; j++) {\n                var value = xVector[j * 2 + 1];\n                z[i][j] = value;\n                if (value < minZ) minZ = value;\n                if (value > maxZ) maxZ = value;\n            }\n        }\n        return {\n            z: z,\n            minX: spectra[0].data[0][0],\n            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n            minY: spectra[0].pageValue,\n            maxY: spectra[ySize - 1].pageValue,\n            minZ: minZ,\n            maxZ: maxZ,\n            noise: getMedian(z[0].map(Math.abs))\n        };\n\n    }\n\n    function add2D(result, options) {\n        var zData = convertTo3DZ(result.spectra);\n        if (!options.noContour) {\n            result.contourLines = generateContourLines(zData, options);\n            delete zData.z;\n        }\n        result.minMax = zData;\n    }\n\n\n    function generateContourLines(zData, options) {\n        var noise = zData.noise;\n        var z = zData.z;\n        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n        var isOver0, isOver1, isOver2, isOver3;\n        var nbSubSpectra = z.length;\n        var nbPovars = z[0].length;\n        var pAx, pAy, pBx, pBy;\n\n        var x0 = zData.minX;\n        var xN = zData.maxX;\n        var dx = (xN - x0) / (nbPovars - 1);\n        var y0 = zData.minY;\n        var yN = zData.maxY;\n        var dy = (yN - y0) / (nbSubSpectra - 1);\n        var minZ = zData.minZ;\n        var maxZ = zData.maxZ;\n\n        //System.out.prvarln('y0 '+y0+' yN '+yN);\n        // -------------------------\n        // Povars attribution\n        //\n        // 0----1\n        // |  / |\n        // | /  |\n        // 2----3\n        //\n        // ---------------------d------\n\n        var iter = options.nbContourLevels * 2;\n        var contourLevels = new Array(iter);\n        var lineZValue;\n        for (var level = 0; level < iter; level++) { // multiply by 2 for positif and negatif\n            var contourLevel = {};\n            contourLevels[level] = contourLevel;\n            var side = level % 2;\n            var factor = (maxZ - options.noiseMultiplier * noise) * Math.exp((level >> 1) - options.nbContourLevels);\n            if (side === 0) {\n                lineZValue = factor + options.noiseMultiplier * noise;\n            } else {\n                lineZValue = (0 - factor) - options.noiseMultiplier * noise;\n            }\n            var lines = [];\n            contourLevel.zValue = lineZValue;\n            contourLevel.lines = lines;\n\n            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n                var subSpectra = z[iSubSpectra];\n                var subSpectraAfter = z[iSubSpectra + 1];\n                for (var povar = 0; povar < nbPovars - 1; povar++) {\n                    povarHeight0 = subSpectra[povar];\n                    povarHeight1 = subSpectra[povar + 1];\n                    povarHeight2 = subSpectraAfter[povar];\n                    povarHeight3 = subSpectraAfter[povar + 1];\n\n                    isOver0 = (povarHeight0 > lineZValue);\n                    isOver1 = (povarHeight1 > lineZValue);\n                    isOver2 = (povarHeight2 > lineZValue);\n                    isOver3 = (povarHeight3 > lineZValue);\n\n                    // Example povar0 is over the plane and povar1 and\n                    // povar2 are below, we find the varersections and add\n                    // the segment\n                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n                        pAy = iSubSpectra;\n                        pBx = povar;\n                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n                        lines.push(pAx * dx + x0);\n                        lines.push(pAy * dy + y0);\n                        lines.push(pBx * dx + x0);\n                        lines.push(pBy * dy + y0);\n                    }\n                    // remove push does not help !!!!\n                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n                        pAx = povar + 1;\n                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n                        pBy = iSubSpectra + 1;\n                        lines.push(pAx * dx + x0);\n                        lines.push(pAy * dy + y0);\n                        lines.push(pBx * dx + x0);\n                        lines.push(pBy * dy + y0);\n                    }\n                    // test around the diagonal\n                    if (isOver1 !== isOver2) {\n                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n                        if (isOver1 !== isOver0) {\n                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n                            pBy = iSubSpectra;\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver0) {\n                            pBx = povar;\n                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver1 !== isOver3) {\n                            pBx = povar + 1;\n                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver3) {\n                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n                            pBy = iSubSpectra + 1;\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                    }\n                }\n            }\n        }\n\n        return {\n            minX: zData.minX,\n            maxX: zData.maxX,\n            minY: zData.minY,\n            maxY: zData.maxY,\n            segments: contourLevels\n        };\n    }\n\n    function fastParseXYData(spectrum, value) {\n        // TODO need to deal with result\n        //  console.log(value);\n        // we check if deltaX is defined otherwise we calculate it\n\n        var yFactor = spectrum.yFactor;\n        var deltaX = spectrum.deltaX;\n\n\n        spectrum.isXYdata = true;\n        // TODO to be improved using 2 array {x:[], y:[]}\n        var currentData = [];\n        spectrum.data = [currentData];\n\n\n        var currentX = spectrum.firstX;\n        var currentY = spectrum.firstY;\n\n        // we skip the first line\n        //\n        var endLine = false;\n        var ascii;\n        for (var i = 0; i < value.length; i++) {\n            ascii = value.charCodeAt(i);\n            if (ascii === 13 || ascii === 10) {\n                endLine = true;\n            } else {\n                if (endLine) break;\n            }\n        }\n\n        // we proceed taking the i after the first line\n        var newLine = true;\n        var isDifference = false;\n        var isLastDifference = false;\n        var lastDifference = 0;\n        var isDuplicate = false;\n        var inComment = false;\n        var currentValue = 0;\n        var isNegative = false;\n        var inValue = false;\n        var skipFirstValue = false;\n        var decimalPosition = 0;\n        for (; i <= value.length; i++) {\n            if (i === value.length) ascii = 13;\n            else ascii = value.charCodeAt(i);\n            if (inComment) {\n                // we should ignore the text if we are after $$\n                if (ascii === 13 || ascii === 10) {\n                    newLine = true;\n                    inComment = false;\n                }\n            } else {\n                // when is it a new value ?\n                // when it is not a digit, . or comma\n                // it is a number that is either new or we continue\n                if (ascii <= 57 && ascii >= 48) { // a number\n                    inValue = true;\n                    if (decimalPosition > 0) {\n                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n                    } else {\n                        currentValue *= 10;\n                        currentValue += ascii - 48;\n                    }\n                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n                    inValue = true;\n                    decimalPosition++;\n                } else {\n                    if (inValue) {\n                        // need to process the previous value\n                        if (newLine) {\n                            newLine = false; // we don't check the X value\n                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n                            // if new line and lastDifference, the first value is just a check !\n                            // that we don't check ...\n                            if (isLastDifference) skipFirstValue = true;\n                        } else {\n                            // need to deal with duplicate and differences\n                            if (skipFirstValue) {\n                                skipFirstValue = false;\n                            } else {\n                                if (isDifference) {\n                                    lastDifference = isNegative ? (0 - currentValue) : currentValue;\n                                    isLastDifference = true;\n                                    isDifference = false;\n                                }\n                                var duplicate = isDuplicate ? currentValue - 1 : 1;\n                                for (var j = 0; j < duplicate; j++) {\n                                    if (isLastDifference) {\n                                        currentY += lastDifference;\n                                    } else {\n                                        currentY = isNegative ? (0 - currentValue) : currentValue;\n                                    }\n                                    currentData.push(currentX);\n                                    currentData.push(currentY * yFactor);\n                                    currentX += deltaX;\n                                }\n                            }\n                        }\n                        isNegative = false;\n                        currentValue = 0;\n                        decimalPosition = 0;\n                        inValue = false;\n                        isDuplicate = false;\n                    }\n\n                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                    if ((ascii < 74) && (ascii > 63)) {\n                        inValue = true;\n                        isLastDifference = false;\n                        currentValue = ascii - 64;\n                    } else\n                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                    if ((ascii > 96) && (ascii < 106)) {\n                        inValue = true;\n                        isLastDifference = false;\n                        currentValue = ascii - 96;\n                        isNegative = true;\n                    } else\n                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                    if (ascii === 115) {\n                        inValue = true;\n                        isDuplicate = true;\n                        currentValue = 9;\n                    } else if ((ascii > 82) && (ascii < 91)) {\n                        inValue = true;\n                        isDuplicate = true;\n                        currentValue = ascii - 82;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if ((ascii > 73) && (ascii < 83)) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = ascii - 73;\n                    } else\n                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n                    if ((ascii > 105) && (ascii < 115)) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = ascii - 105;\n                        isNegative = true;\n                    } else\n                    // $ sign, we need to check the next one\n                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n                        inValue = true;\n                        inComment = true;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if (ascii === 37) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = 0;\n                        isNegative = false;\n                    } else if (ascii === 45) { // a \"-\"\n                        // check if after there is a number, decimal or comma\n                        var ascii2 = value.charCodeAt(i + 1);\n                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n                            inValue = true;\n                            isLastDifference = false;\n                            isNegative = true;\n                        }\n                    } else if (ascii === 13 || ascii === 10) {\n                        newLine = true;\n                        inComment = false;\n                    }\n                    // and now analyse the details ... space or tabulation\n                    // if \"+\" we just don't care\n                }\n            }\n        }\n    }\n\n    function parsePeakTable(spectrum, value, result) {\n        var removeCommentRegExp = /\\$\\$.*/;\n        var peakTableSplitRegExp = /[,\\t ]+/;\n\n        spectrum.isPeaktable = true;\n        var i, ii, j, jj, values;\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        // counts for around 20% of the time\n        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n        for (i = 1, ii = lines.length; i < ii; i++) {\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n            if (values.length % 2 === 0) {\n                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n                    currentData.push(parseFloat(values[j]) * spectrum.xFactor);\n                    currentData.push(parseFloat(values[j + 1]) * spectrum.yFactor);\n                }\n            } else {\n                result.logs.push('Format error: ' + values);\n            }\n        }\n    }\n\n\n    return convert;\n\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n    if (typeof options === 'boolean') {\n        useWorker = options;\n        options = {};\n    }\n    if (useWorker) {\n        return postToWorker(input, options);\n    } else {\n        return convert(input, options);\n    }\n}\n\nvar stamps = {};\nvar worker;\n\nfunction postToWorker(input, options) {\n    if (!worker) {\n        createWorker();\n    }\n    return new Promise(function (resolve) {\n        var stamp = Date.now() + '' + Math.random();\n        stamps[stamp] = resolve;\n        worker.postMessage(JSON.stringify({\n            stamp: stamp,\n            input: input,\n            options: options\n        }));\n    });\n}\n\nfunction createWorker() {\n    var workerURL = URL.createObjectURL(new Blob([\n        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };'\n    ], {type: 'application/javascript'}));\n    worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    worker.addEventListener('message', function (event) {\n        var data = JSON.parse(event.data);\n        var stamp = data.stamp;\n        if (stamps[stamp]) {\n            stamps[stamp](data.output);\n        }\n    });\n}\n\nmodule.exports = {\n    convert: JcampConverter\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}